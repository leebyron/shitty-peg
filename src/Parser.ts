'use strict';

import invariant = require('./invariant');
import Stack = require('./Stack');



/**
 * Primary entry point, Parser.parse() takes a string and parse function and
 * runs the parser.
 *
 *     Parser.parse(Parser.Source('abc'), myParseFn);
 *
 */
export function parse<T>(
  source: Source,
  parser: (c: Parse) => T,
  callback?: (error: ParseError, ast: T) => void
): T {
  return new Parse(source).run(parser, callback);
}

/**
 * Define tokens.
 */
export function token(rx: RegExp, name?: string): Token;
export function token(str: string, name?: string): Token;

export function token(strOrRx, name?: string): Token {
  return strOrRx instanceof RegExp ?
    new RegExpToken(strOrRx, name) :
    new StringToken(strOrRx, name);
}

export interface Token {
  tokenize(p: Parse): string;
  description(): string;
}

/**
 * Identify sources.
 */
export class Source {
  constructor(
    public body: string,
    public name?: string
  ) {}
}



/**
 * A ParseError generated by a Parse.
 * Provided as an argument in the callback given to Parse.parse()
 * Includes information about the line and column where the error was
 * encountered, along with information about what was expected.
 */
export class ParseError {
  public location: Location;
  public expected: Array<string> = [];

  toString(): string {
    var unexpected = this.location.offset === this.location.source.body.length ?
      'End of source' : tokenDesc(this.location.source.body[this.location.offset]);
    return (
      'Unexpected ' + unexpected + '. ' +
      'Expected ' + this.expected.join(' or ') + ' at ' + this.location
    );
  }
}



/**
 * Provided as part of a ParseError. Use to provide clear information about
 * the parse error.
 */
export class Location {
  constructor(
    public source: Source,
    public offset: number
  ) {}

  toString(): string {
    var lc = this.lineColumn();
    return [
      this.source.name, lc.line, lc.column
    ].filter(x => !!x).join(':');
  }

  line(): number {
    return this.lineColumn().line;
  }

  column(): number {
    return this.lineColumn().column;
  }

  private lineColumn(): {line: number; column: number} {
    var nl = /\n/g;
    var line = 0;
    var column;
    var data = {index: -1};
    do {
      line++;
      column = this.offset - data.index;
      data = nl.exec(this.source.body);
    } while (data && data.index < this.offset);
    return {line: line, column: column};
  }
}



/**
 * A parsing operation. Chain methods to define and run a parse:
 */
export class Parse {

  public source: Source;
  public offset: number;



  // # Parse rules

  /**
   * True if the token is the next to be encountered.
   */
  isNext(token: Token): boolean;
  isNext(token: string): boolean;
  isNext(token: RegExp): boolean;

  isNext(t) {
    this._whitespace();
    return !!tokenize(this, t);
  }

  /**
   * Expect the token to be consumed, otherwise a ParseError.
   */
  skip(token: Token): Parse;
  skip(token: string): Parse;
  skip(token: RegExp): Parse;
  skip(parser: (c: Parse) => any): Parse;

  skip(token) {
    this.one(token);
    return this;
  }

  /**
   * Expect the token/parser to be found, otherwise a ParseError.
   * Returns the parsed result.
   */
  one(token: Token): string;
  one(token: string): string;
  one(token: RegExp): string;
  one<T>(parser: (c: Parse) => T): T;

  one(t) {
    if (typeof t === 'function') {
      return t(this);
    }
    this._whitespace();
    var result = tokenize(this, t);
    if (!result) {
      this.expected(tokenDesc(t));
    }
    this.offset += result.length;
    return result;
  }


  /**
   * Runs each parser in order, stopping once one has completed without
   * encountering a ParseError. If all parsers fail, the one which parsed
   * the furthest will present it's ParseError.
   */
  oneOf(...tokenOrParsers) {
    for (var ii = 0; ii < arguments.length; ii++) {
      try {
        var copy = this._copy();
        var result = copy.one(arguments[ii]);
        this._resume(copy);
        return result;
      } catch (error) {
        if (error !== this._syntaxError) {
          throw error;
        }
      }
    }
    throw this._syntaxError;
  }
  //oneOf(...tokenOrParsers: Array<Token|string|RegExp|(c: Parse) => any>): any;


  /**
   * Runs the parser as many times as possible, running the delimiterParser
   * between each run. Continues until a parser fails, returns an array of
   * parsed tokens, skipping delimiter.
   */
  any(token, delimiter?) {
    return this._list(token, delimiter, /* requireOne */ false);
  }
  //any(
  //  token: Token|string|RegExp
  //  delimiter?: Token|string|RegExp|(c: Parse) => T
  //): string[]
  //any<T>(
  //  token: (c: Parse) => T
  //  delimiter?: Token|string|RegExp|(c: Parse) => T
  //): T[]


  /**
   * Like any(), but requires at least one successful parse.
   */
  many(token, delimiter?) {
    return this._list(token, delimiter, /* requireOne */ true);
  }
  //many(
  //  token: Token|string|RegExp
  //  delimiter?: Token|string|RegExp|(c: Parse) => T
  //): string[]
  //many<T>(
  //  token: (c: Parse) => T
  //  delimiter?: Token|string|RegExp|(c: Parse) => T
  //): T[]


  /**
   * Runs the parser, returns undefined if the parser failed, but does not
   * result in a ParseError.
   */
  optional<T>(parser: (c: Parse) => T): T {
    try {
      var copy = this._copy();
      var result = copy.one(parser);
      this._resume(copy);
      return result;
    } catch (error) {
      if (error !== this._syntaxError) {
        throw error;
      }
    }
  }

  /**
   * Non-consuming look-ahead. Syntax error if it fails.
   */
  and(token): Parse {
    this._copy().one(token);
    return this;
  }

  /**
   * Non-consuming look-ahead. Syntax error if it succeeds.
   */
  not(token): Parse {
    try {
      this._copy().one(token);
    } catch (error) {
      return this;
    }
    this.expected('not ' + tokenDesc(token));
  }

  /**
   * If newlines are significant, skips a newline with the same indentation.
   */
  newline(): Parse {
    return this._line(IndentationDirection.NEWLINE);
  }

  /**
   * If newlines are significant, skips a newline with more indentation.
   */
  indent(): Parse {
    if (this.offset === 0) {
      return this;
    }
    return this._line(IndentationDirection.INDENT);
  }

  /**
   * If newlines are significant, skips a newline with less indentation.
   * Note: Does not consume the newline.
   */
  dedent(): Parse {
    if (this.offset === this.source.body.length) {
      return this;
    }
    return this._line(IndentationDirection.DEDENT);
  }

  /**
   * Expect the end of the file, otherwise a ParseError.
   */
  end(): Parse {
    this._whitespace(WhiteSpaceStyle.MULTI_LINE);
    if (this.offset !== this.source.body.length) {
      this.expected('End of source');
    }
    return this;
  }

  /**
   * Provide a description and a valid ParseError will be returned.
   */
  expected(tokenDescription: string): void {
    if (this.offset > this._syntaxError.location.offset) {
      this._syntaxError.location.offset = this.offset;
      this._syntaxError.expected.length = 0;
    }
    if (this.offset >= this._syntaxError.location.offset) {
      this._syntaxError.expected.push(tokenDescription);
    }
    throw this._syntaxError;
  }



  // # Metadata

  /**
   * Returns a location descriptor for the current state of the Parse.
   *
   * Useful if your AST should have location information.
   */
  location(): Location {
    this._whitespace();
    return new Location(this.source, this.offset);
  }



  // # Whitespace significance

  /**
   * By default, the parser treats whitespace as significant.
   * To treat it as insignificant, use one of the pushWhitespace methods below
   * and later call popWhitespaceSignificance() to revert to the previous value.
   */
  popWhitespaceSignificance(): Parse {
    this._sigWhitespace = this._sigWhitespace.pop();
    return this;
  }

  /**
   * In this mode, all whitespace is insignificant, including line breaks.
   */
  pushWhitespaceInsignificant(): Parse {
    this._sigWhitespace = this._sigWhitespace.push(WhiteSpaceStyle.MULTI_LINE);
    return this;
  }

  /**
   * In this mode, spaces and tabs are insignificant, but line breaks are not.
   */
  pushWhitespaceInsignificantSingleLine(): Parse {
    this._sigWhitespace = this._sigWhitespace.push(WhiteSpaceStyle.SINGLE_LINE);
    return this;
  }

  /**
   * In this mode, all spacing is significant, this is the default.
   */
  pushWhitespaceAllSignificant(): Parse {
    this._sigWhitespace = this._sigWhitespace.push(WhiteSpaceStyle.NONE);
    return this;
  }


  // # Context

  /**
   * Arbitrary data provided to be tracked and retrieved while parsing.
   */
  context(): any {
    return this._context.value;
  }

  setContext(context: any): Parse {
    this._context = this._context.pop().push(context);
    return this;
  }

  pushContext(context: any): Parse {
    this._context = this._context.push(context);
    return this;
  }

  popContext(): Parse {
    this._context = this._context.pop();
    return this;
  }


  // # Special Use

  /**
   * Create a new parse operation from a given source.
   *
   * Usually just call Parser.parse() directly
   */
  constructor(source: Source) {
    this.source = source;
    this.offset = 0;
    this._context = new Stack();
    this._depth = new Stack(0);
    this._sigWhitespace = new Stack(WhiteSpaceStyle.NONE);
    this._syntaxError = new ParseError();
    this._syntaxError.location = new Location(source, 0);
  }

  /**
   * Start a Parse with a given parser.
   */
  run<T>(
    parser: (c: Parse) => T,
    callback?: (error: ParseError, ast: T) => void
  ): T {
    this.offset = 0;
    try {
      var ast = this.one(parser);
      this.end();
      callback && callback(null, ast);
      return ast;
    } catch (error) {
      if (error !== this._syntaxError) {
        throw error;
      }
      // Clean up the error.
      this._syntaxError.expected = unique(this._syntaxError.expected);
      if (callback) {
        callback(this._syntaxError, null);
      } else {
        throw new Error(this._syntaxError.toString());
      }
    }
  }



  // Private

  private _context: Stack<any>;
  private _depth: Stack<number>;
  private _sigWhitespace: Stack<WhiteSpaceStyle>;
  private _syntaxError: ParseError;

  private _copy(): Parse {
    return (new Parse(this.source))._resume(this);
  }

  private _resume(c: Parse): Parse {
    if (this !== c) {
      this.source = c.source;
      this.offset = c.offset;
      this._context = c._context;
      this._depth = c._depth;
      this._sigWhitespace = c._sigWhitespace;
      this._syntaxError = c._syntaxError;
    }
    return this;
  }

  private _whitespace(style?: WhiteSpaceStyle): Parse {
    style = style || this._sigWhitespace.value;
    if (style === WhiteSpaceStyle.NONE) {
      return this;
    }
    var sp = tokenizeRx(
      this,
      style === WhiteSpaceStyle.MULTI_LINE ?
        ALL_WHITESPACE_RX :
        SINGLE_LINE_WHITESPACE_RX
    );
    if (sp) {
      this.offset += sp.length;
    }
    return this;
  }

  private _line(direction: IndentationDirection): Parse {
    var style = this._sigWhitespace.value;
    invariant(
      style !== WhiteSpaceStyle.MULTI_LINE,
      'Cannot parse significant lines when white space is insignificant'
    );
    var c = this._whitespace();

    var offset = c.offset;
    var depth;
    if (c.source.body[offset] !== '\n') {
      this.expected(indentationDesc(direction));
    }
    offset++;
    while (true) {
      depth = 0;
      while (true) {
        var next = c.source.body[offset];
        if (next === ' ') {
          depth++;
          offset++;
        } else if (next === '\t') {
          depth += 2;
          offset++;
        } else {
          break;
        }
      }
      if (c.source.body[offset] !== '\n') {
        break;
      }
      offset++;
    }
    if (direction !== IndentationDirection.DEDENT) {
      c.offset = offset;
    }

    var currentDepth = this._depth.value;
    if (direction === IndentationDirection.NEWLINE) {
      if (depth !== currentDepth) {
        this.expected(indentationDesc(direction));
      }
      this._resume(c);
    } else if (direction === IndentationDirection.INDENT) {
      if (depth <= currentDepth) {
        this.expected(indentationDesc(direction));
      }
      this._resume(c);
      this._depth = this._depth.push(depth);
    } else if (direction === IndentationDirection.DEDENT) {
      var prevDepth = this._depth.pop().value;
      if (depth > prevDepth) {
        this.expected(indentationDesc(direction));
      }
      this._depth = this._depth.pop();
    } else {
      invariant(false, 'Unexpected direction ' + direction);
    }
    return this;
  }

  private _list<T>(
    token: any,
    delimiter?: any,
    requireOne?: boolean
  ): Array<T> {
    var c: Parse = this;
    var astList = [];
    try {
      while (true) {
        var nextCtx = c._copy();
        if (delimiter && astList.length > 0) {
          nextCtx.one(delimiter);
        }
        var ast = nextCtx.one(token);
        c = nextCtx;
        invariant(c != null, 'parser must return a context');
        astList.push(ast);
      }
    } catch (error) {
      if (error !== this._syntaxError) {
        throw error;
      }
      if (requireOne && astList.length == 0) {
        throw error;
      }
    }
    this._resume(c);
    return astList;
  }
}

var ALL_WHITESPACE_RX = /^\s+/;
var SINGLE_LINE_WHITESPACE_RX = /^(?:[ \t]|(?:\\\n))+/;

enum WhiteSpaceStyle {
  SINGLE_LINE = 1,
  MULTI_LINE,
  NONE
}

enum IndentationDirection {
  DEDENT,
  NEWLINE,
  INDENT
}

function indentationDesc(dir: IndentationDirection) {
  switch (dir) {
    case IndentationDirection.DEDENT: return 'Dedent';
    case IndentationDirection.NEWLINE: return 'Newline';
    case IndentationDirection.INDENT: return 'Indent';
  }
}

function unique(list: Array<string>): Array<string> {
  var existsSet = {};
  return list.filter(item => !existsSet[item] && (existsSet[item] = true));
}

function tokenDesc(maybeToken) {
  return (
    maybeToken.description ? maybeToken.description() :
    maybeToken instanceof RegExp ? tokenDescRx(maybeToken) :
    maybeToken instanceof Function ? maybeToken.name :
    tokenDescStr(maybeToken)
  );
}

function tokenDescStr(str) {
  return JSON.stringify(str);
}

function tokenDescRx(rx) {
  return rx.source;
}

function tokenize(p, maybeToken) {
  return (
    typeof maybeToken === 'string' ? tokenizeStr(p, maybeToken) :
    maybeToken.tokenize ? maybeToken.tokenize(p) :
    maybeToken instanceof RegExp ? tokenizeRx(p, maybeToken) :
    null
  );
}

function tokenizeStr(p, str) {
  return str === p.source.body.substr(p.offset, str.length) && str;
}

function tokenizeRx(p, rx) {
  if (!rx.__tokenSafe) {
    if (rx.source[0] !== '^') {
      throw new Error('RegExp Token must start with ^');
    }
    rx.__tokenSafe = true;
  }
  var data = rx.exec(p.source.body.substr(p.offset));
  return data && data[0];
}


class StringToken implements Token {
  constructor(private token: string, private name?: string) {
    this.token = token;
    this.name = name;
  }

  tokenize(p: Parse): string {
    return tokenizeStr(p, this.token);
  }

  description(): string {
    return this.name || tokenDescStr(this.token);
  }
}

class RegExpToken implements Token {
  constructor(private token: RegExp, private name?: string) {
    this.token = token;
    this.name = name;
  }

  tokenize(p: Parse): string {
    return tokenizeRx(p, this.token);
  }

  description(): string {
    return this.name || tokenDescRx(this.token);
  }
}
