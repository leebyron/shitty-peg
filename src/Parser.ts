'use strict';

import invariant = require('./invariant');
import Stack = require('./Stack');



/**
 * Primary entry point, Parser.parse() takes a string and parse function and
 * runs the parser.
 *
 *     Parser.parse(Parser.Source('abc'), myParseFn);
 *
 */
export function parse<T>(
  source: Source,
  parser: (c: Parse) => T,
  callback?: (error: ParseError, ast: T) => void
): T {
  return new Parse(source).run(parser, callback);
}


export class Source {
  constructor(
    public body: string,
    public name?: string
  ) {}
}



/**
 * A syntax error generated by a Parse.
 * Provided as an argument in the callback given to Parse.parse()
 * Includes information about the line and column where the error was
 * encountered, along with information about what was expected.
 */
export class ParseError {
  public location: Location;
  public expected: Array<string> = [];

  toString(): string {
    var unexpected = this.location.offset === this.location.source.body.length ?
      'EOF' : readableToken(this.location.source.body[this.location.offset]);
    return 'Syntax error: unexpected "' + unexpected + '". ' +
      'Expected ' + this.expected.join(' or ') + ' at ' + this.location;
  }
}



/**
 * Provided as part of a ParseError. Use to provide clear information about
 * the parse error.
 */
export class Location {
  constructor(
    public source: Source,
    public offset: number
  ) {}

  toString(): string {
    var lc = this.lineColumn();
    return [
      this.source.name, lc.line, lc.column
    ].filter(x => !!x).join(':');
  }

  line(): number {
    return this.lineColumn().line;
  }

  column(): number {
    return this.lineColumn().column;
  }

  private lineColumn(): {line: number; column: number} {
    var nl = /\n/g;
    var line = 0;
    var column;
    var data = {index: -1};
    do {
      line++;
      column = this.offset - data.index;
      data = nl.exec(this.source.body);
    } while (data && data.index < this.offset);
    return {line: line, column: column};
  }
}



/**
 * A parsing operation. Chain methods to define and run a parse:
 */
export class Parse {

  /**
   * Create a new parse operation from a given source.
   */
  constructor(source: Source) {
    this._source = source;
    this._context = new Stack();
    this._offset = 0;
    this._depth = new Stack(0);
    this._sigWhitespace = new Stack(WhiteSpaceStyle.NONE);
    this._syntaxError = new ParseError();
    this._syntaxError.location = new Location(source, 0);
  }

  run<T>(
    parser: (c: Parse) => T,
    callback?: (error: ParseError, ast: T) => void
  ): T {
    this._offset = 0;
    try {
      var ast = this.one(parser);
      this.eof();
      callback && callback(null, ast);
      return ast;
    } catch (error) {
      if (error !== this._syntaxError) {
        throw error;
      }
      // Clean up the error.
      this._syntaxError.expected = unique(this._syntaxError.expected).map(readableToken);
      if (callback) {
        callback(this._syntaxError, null);
      } else {
        throw new Error(this._syntaxError.toString());
      }
    }
  }

  /**
   * By default, the parser treats whitespace as significant.
   * To treat it as insignificant, use one of the pushWhitespace methods below
   * and later call popWhitespaceSignificance() to revert to the previous value.
   */
  popWhitespaceSignificance(): Parse {
    this._sigWhitespace = this._sigWhitespace.pop();
    return this;
  }

  /**
   * In this mode, all whitespace is insignificant, including line breaks.
   */
  pushWhitespaceInsignificant(): Parse {
    this._sigWhitespace = this._sigWhitespace.push(WhiteSpaceStyle.MULTI_LINE);
    return this;
  }

  /**
   * In this mode, spaces and tabs are insignificant, but line breaks are not.
   */
  pushWhitespaceInsignificantSingleLine(): Parse {
    this._sigWhitespace = this._sigWhitespace.push(WhiteSpaceStyle.SINGLE_LINE);
    return this;
  }

  /**
   * In this mode, all spacing is significant, this is the default.
   */
  pushWhitespaceAllSignificant(): Parse {
    this._sigWhitespace = this._sigWhitespace.push(WhiteSpaceStyle.NONE);
    return this;
  }

  /**
   * Arbitrary data provided to be tracked and retrieved while parsing.
   */
  context(): any {
    return this._context.value;
  }

  setContext(context: any): Parse {
    this._context = this._context.pop().push(context);
    return this;
  }

  pushContext(context: any): Parse {
    this._context = this._context.push(context);
    return this;
  }

  popContext(): Parse {
    this._context = this._context.pop();
    return this;
  }

  /**
   * Returns a location descriptor for the current token.
   */
  location(): Location {
    this._whitespace();
    return new Location(this._source, this._offset);
  }

  /**
   * True if the token is the next to be encountered.
   */
  isNext(token: string): boolean {
    this._whitespace();
    return token === this._source.body.substring(this._offset, this._offset + token.length);
  }

  /**
   * True if the token was encountered and consumed.
   */
  maybe(token: string): boolean {
    var exists = this.isNext(token);
    if (exists) {
      this._offset += token.length;
    }
    return exists;
  }

  /**
   * Expect the token to be consumed, otherwise a syntax error.
   */
  expect(token: string): Parse {
    if (!this.isNext(token)) {
      this._expected(token);
    }
    this._offset += token.length;
    return this;
  }

  /**
   * Expect the token/regex/parser to be found, otherwise a syntax error.
   * Returns the parsed result.
   */
  one<T>(token: string, value?: T): T;
  one(regex: RegExp): string;
  one<T>(regex: RegExp, mapper?: (data: any) => T): T;
  one<T>(parser: (c: Parse) => T): T;

  one(parser, mapper?) {
    var type = typeof parser;
    if (type === 'function') {
      return parser(this);
    }
    if (type === 'string') {
      this.expect(parser);
      return arguments.length === 2 ? mapper : parser;
    }
    if (parser instanceof RegExp) {
      return this._regexp(parser, mapper);
    }
  }

  /**
   * Expect the end of the file, otherwise a syntax error.
   */
  eof(): Parse {
    this._whitespace(WhiteSpaceStyle.MULTI_LINE);
    if (this._offset !== this._source.body.length) {
      this._expected('EOF');
    }
    return this;
  }

  /**
   * If newlines are significant, expects a newline with the same indentation.
   */
  newline(): Parse {
    return this._line(0);
  }

  /**
   * If newlines are significant, expects a newline with more indentation.
   */
  indent(): Parse {
    if (this._offset === 0) {
      return this;
    }
    return this._line(1);
  }

  /**
   * If newlines are significant, expects a newline with less indentation.
   * Note: Does not consume the newline.
   */
  dedent(): Parse {
    if (this._offset === this._source.body.length) {
      return this;
    }
    return this._line(-1);
  }

  /**
   * Runs each parser in order, stopping once one has completed without
   * encountering a ParseError. If all parsers fail, the one which parsed
   * the furthest will present it's ParseError.
   */
  //oneOf<T>(...parsers: Array<(c: Parse) => T>): T;
  oneOf<T>(...parsers) {
    var bestError;
    for (var ii = 0; ii < parsers.length; ii++) {
      try {
        var copy = this._copy();
        var result = copy.one(parsers[ii]);
        this._resume(copy);
        return result;
      } catch (error) {
        if (error !== this._syntaxError) {
          throw error;
        }
      }
    }
    throw this._syntaxError;
  }

  /**
   * Runs the parser, returns undefined if the parser failed, but does not
   * result in a ParseError.
   */
  optional<T>(parser: (c: Parse) => T): T {
    try {
      var copy = this._copy();
      var result = parser(copy);
      this._resume(copy);
      return result;
    } catch (error) {
      if (error !== this._syntaxError) {
        throw error;
      }
    }
  }

  /**
   * Runs the parser as many times as possible, running the delimiterParser
   * between each run. Continues until a parser fails, returns an array of
   * parse results.
   */
  //any(token: string, delimiter?: (c: Parse) => any): string[];
  //any(token: string, delimiter?: string): string[];
  //any(token: string, delimiter?: RegExp): string[];
  //any(regex: RegExp, delimiter?: (c: Parse) => any): string[];
  //any(regex: RegExp, delimiter?: string): string[];
  //any(regex: RegExp, delimiter?: RegExp): string[];
  //any<T>(parser: (c: Parse) => T, delimiter?: (c: Parse) => any): T[];
  //any<T>(parser: (c: Parse) => T, delimiter?: string): T[];
  //any<T>(parser: (c: Parse) => T, delimiter?: RegExp): T[];
  any(token, delimiter?) {
    return this._list(token, delimiter, /* requireOne */ false);
  }

  /**
   * Like any(), but expects at least one successful parse.
   */

  //many(token: string, delimiter?: (c: Parse) => any): string[];
  //many(token: string, delimiter?: string): string[];
  //many(token: string, delimiter?: RegExp): string[];
  //many(regex: RegExp, delimiter?: (c: Parse) => any): string[];
  //many(regex: RegExp, delimiter?: string): string[];
  //many(regex: RegExp, delimiter?: RegExp): string[];
  //many<T>(parser: (c: Parse) => T, delimiter?: (c: Parse) => any): T[];
  //many<T>(parser: (c: Parse) => T, delimiter?: string): T[];
  //many<T>(parser: (c: Parse) => T, delimiter?: RegExp): T[];

  many(token, delimiter?) {
    return this._list(token, delimiter, /* requireOne */ true);
  }

  // Private

  private _source: Source;
  private _context: Stack<any>;
  private _offset: number;
  private _depth: Stack<number>;
  private _sigWhitespace: Stack<WhiteSpaceStyle>;
  private _syntaxError: ParseError;

  private _copy(): Parse {
    return (new Parse(this._source))._resume(this);
  }

  private _resume(c: Parse): Parse {
    if (this !== c) {
      this._source = c._source;
      this._context = c._context;
      this._offset = c._offset;
      this._depth = c._depth;
      this._sigWhitespace = c._sigWhitespace;
      this._syntaxError = c._syntaxError;
    }
    return this;
  }

  private _expected(token: string): void {
    if (this._offset > this._syntaxError.location.offset) {
      this._syntaxError.location.offset = this._offset;
      this._syntaxError.expected.length = 0;
    }
    if (this._offset >= this._syntaxError.location.offset) {
      this._syntaxError.expected.push(token);
    }
    throw this._syntaxError;
  }

  private _whitespace(style?: WhiteSpaceStyle): Parse {
    style = style || this._sigWhitespace.value;
    if (style === WhiteSpaceStyle.NONE) {
      return this;
    }
    var allowNewline = style === WhiteSpaceStyle.MULTI_LINE;
    while (true) {
      var charAt = this._source.body[this._offset];
      if (charAt === ' ' || charAt === '\t' || charAt === '\r' ||
          (allowNewline && charAt === '\n')) {
        this._offset += 1;
      } else if (charAt === '\\') {
        if (this._source.body[this._offset + 1] === '\n') {
          this._offset += 2;
        }
      } else {
        break;
      }
    }
    return this;
  }

  private _line(direction: number): Parse {
    var style = this._sigWhitespace.value;
    invariant(
      style !== WhiteSpaceStyle.MULTI_LINE,
      'Cannot parse significant lines when white space is insignificant'
    );
    var c = this._whitespace();
    if (direction === -1) {
      c = c._copy();
    }
    var depth;
    c = c.pushWhitespaceAllSignificant();
    do {
      c = c.expect('\n');
      depth = 0;
      while (c.isNext(' ') || c.isNext('\t')) {
        if (c.isNext(' ')) {
          depth += 1;
        } else if (c.isNext('\t')) {
          depth += 2;
        }
        c._offset += 1;
      }
    } while (c.isNext('\n'));
    c = c.popWhitespaceSignificance();

    var currentDepth = this._depth.value;
    if (direction === 0) { // newline
      if (depth !== currentDepth) {
        this._expected('newline');
      }
      this._resume(c);
    } else if (direction === 1) { // indent
      if (depth <= currentDepth) {
        this._expected('indent');
      }
      this._resume(c);
      this._depth = this._depth.push(depth);
    } else if (direction === -1) { // dedent
      var prevDepth = this._depth.pop().value;
      if (depth > prevDepth) {
        this._expected('dedent');
      }
      this._depth = this._depth.pop();
    } else {
      invariant(false, 'Unexpected direction ' + direction);
    }
    return this;
  }

  private _list<T>(
    token: any,
    delimiter?: any,
    requireOne?: boolean
  ): Array<T> {
    var c: Parse = this;
    var astList = [];
    try {
      while (true) {
        var nextCtx = c._copy();
        if (delimiter && astList.length > 0) {
          nextCtx.one(delimiter);
        }
        var ast = nextCtx.one(token);
        c = nextCtx;
        invariant(c != null, 'parser must return a context');
        astList.push(ast);
      }
    } catch (error) {
      if (error !== this._syntaxError) {
        throw error;
      }
      if (requireOne && astList.length == 0) {
        throw error;
      }
    }
    this._resume(c);
    return astList;
  }

  private _regexp(regex: RegExp, mapper?: (data: any) => any): any {
    invariant(regex.source[0] === '^', 'RegExp must start with ^');
    this._whitespace();
    var data = regex.exec(this._source.body.substr(this._offset));
    if (!data) {
      this._expected((<any>regex).name || regex.source);
    }
    this._offset += data[0].length;
    return mapper ? mapper.apply(null, data) : data[0];
  }
}

enum WhiteSpaceStyle {
  SINGLE_LINE = 1,
  MULTI_LINE,
  NONE
}

function unique(list: Array<string>): Array<string> {
  var existsSet = {};
  return list.filter(item => !existsSet[item] && (existsSet[item] = true));
}

function readableToken(token: string): string {
  switch (token) {
    case '\n': return '\\n';
    case ' ': return '<sp>';
    default: return token;
  }
}
