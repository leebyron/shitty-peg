/**
* Primary entry point, Parser.parse() takes a string and parse function and
* runs the parser.
*
*     Parser.parse(Parser.Source('abc'), myParseFn);
*
*/
export declare function parse<T>(source: Source, parser: (c: Parse) => T, callback?: (error: ParseError, ast: T) => void): T;
export declare class Source {
    public body: string;
    public name: string;
    constructor(body: string, name?: string);
}
/**
* A syntax error generated by a Parse.
* Provided as an argument in the callback given to Parse.parse()
* Includes information about the line and column where the error was
* encountered, along with information about what was expected.
*/
export declare class ParseError {
    public location: Location;
    public expected: string[];
    public toString(): string;
}
/**
* Provided as part of a ParseError. Use to provide clear information about
* the parse error.
*/
export declare class Location {
    public source: Source;
    public offset: number;
    constructor(source: Source, offset: number);
    public toString(): string;
    public line(): number;
    public column(): number;
    private lineColumn();
}
/**
* A parsing operation. Chain methods to define and run a parse:
*/
export declare class Parse {
    /**
    * Create a new parse operation from a given source.
    */
    constructor(source: Source);
    public run<T>(parser: (c: Parse) => T, callback?: (error: ParseError, ast: T) => void): T;
    /**
    * By default, the parser treats whitespace as significant.
    * To treat it as insignificant, use one of the pushWhitespace methods below
    * and later call popWhitespaceSignificance() to revert to the previous value.
    */
    public popWhitespaceSignificance(): Parse;
    /**
    * In this mode, all whitespace is insignificant, including line breaks.
    */
    public pushWhitespaceInsignificant(): Parse;
    /**
    * In this mode, spaces and tabs are insignificant, but line breaks are not.
    */
    public pushWhitespaceInsignificantSingleLine(): Parse;
    /**
    * In this mode, all spacing is significant, this is the default.
    */
    public pushWhitespaceAllSignificant(): Parse;
    /**
    * Arbitrary data provided to be tracked and retrieved while parsing.
    */
    public context(): any;
    public setContext(context: any): Parse;
    public pushContext(context: any): Parse;
    public popContext(): Parse;
    /**
    * Returns a location descriptor for the current token.
    */
    public location(): Location;
    /**
    * True if the token is the next to be encountered.
    */
    public isNext(token: string): boolean;
    /**
    * True if the token was encountered and consumed.
    */
    public maybe(token: string): boolean;
    /**
    * Expect the token to be consumed, otherwise a syntax error.
    */
    public expect(token: string): Parse;
    /**
    * Expect the token/regex/parser to be found, otherwise a syntax error.
    * Returns the parsed result.
    */
    public one<T>(token: string, value?: T): T;
    public one(regex: RegExp): string;
    public one<T>(regex: RegExp, mapper?: (data: any) => T): T;
    public one<T>(parser: (c: Parse) => T): T;
    /**
    * Expect the end of the file, otherwise a syntax error.
    */
    public eof(): Parse;
    /**
    * If newlines are significant, expects a newline with the same indentation.
    */
    public newline(): Parse;
    /**
    * If newlines are significant, expects a newline with more indentation.
    */
    public indent(): Parse;
    /**
    * If newlines are significant, expects a newline with less indentation.
    * Note: Does not consume the newline.
    */
    public dedent(): Parse;
    public oneOf<T>(...parsers: any[]): {};
    /**
    * Runs the parser, returns undefined if the parser failed, but does not
    * result in a ParseError.
    */
    public optional<T>(parser: (c: Parse) => T): T;
    public any(token: any, delimiter?: any): {}[];
    public many(token: any, delimiter?: any): {}[];
    private _source;
    private _context;
    private _offset;
    private _depth;
    private _sigWhitespace;
    private _syntaxError;
    private _copy();
    private _resume(c);
    private _expected(token);
    private _whitespace(style?);
    private _line(direction);
    private _list<T>(token, delimiter?, requireOne?);
    private _regexp(regex, mapper?);
}
